import { reactive, watch, onScopeDispose, toRefs, readonly } from 'vue-demi';
import { MutationObserver } from '@tanstack/query-core';
import { updateState, isQueryKey, cloneDeepUnref } from './utils.esm.js';
import { useQueryClient } from './useQueryClient.esm.js';

function useMutation(arg1, arg2, arg3) {
  var _options$queryClient;

  const options = parseMutationArgs(arg1, arg2, arg3);
  const queryClient = (_options$queryClient = options.queryClient) != null ? _options$queryClient : useQueryClient(options.queryClientKey);
  const defaultedOptions = queryClient.defaultMutationOptions(options);
  const observer = new MutationObserver(queryClient, defaultedOptions);
  const state = reactive(observer.getCurrentResult());
  const unsubscribe = observer.subscribe(result => {
    updateState(state, result);
  });

  const mutate = (variables, mutateOptions) => {
    observer.mutate(variables, mutateOptions).catch(() => {// This is intentional
    });
  };

  watch([() => arg1, () => arg2, () => arg3], () => {
    observer.setOptions(queryClient.defaultMutationOptions(parseMutationArgs(arg1, arg2, arg3)));
  }, {
    deep: true
  });
  onScopeDispose(() => {
    unsubscribe();
  });
  const resultRefs = toRefs(readonly(state));
  return { ...resultRefs,
    mutate,
    mutateAsync: state.mutate,
    reset: state.reset
  };
}
function parseMutationArgs(arg1, arg2, arg3) {
  let options = arg1;

  if (isQueryKey(arg1)) {
    if (typeof arg2 === 'function') {
      options = { ...arg3,
        mutationKey: arg1,
        mutationFn: arg2
      };
    } else {
      options = { ...arg2,
        mutationKey: arg1
      };
    }
  }

  if (typeof arg1 === 'function') {
    options = { ...arg2,
      mutationFn: arg1
    };
  }

  return cloneDeepUnref(options);
}

export { parseMutationArgs, useMutation };
//# sourceMappingURL=useMutation.esm.js.map
