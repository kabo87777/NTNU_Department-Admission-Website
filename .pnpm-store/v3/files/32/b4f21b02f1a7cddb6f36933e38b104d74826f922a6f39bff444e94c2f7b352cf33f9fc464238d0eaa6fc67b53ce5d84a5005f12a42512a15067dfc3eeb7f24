{"version":3,"file":"useQueries.mjs","sources":["../../src/useQueries.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { QueriesObserver } from '@tanstack/query-core'\nimport { onScopeDispose, reactive, readonly, watch } from 'vue-demi'\nimport type { Ref } from 'vue-demi'\n\nimport type { QueryFunction, QueryObserverResult } from '@tanstack/query-core'\n\nimport { useQueryClient } from './useQueryClient'\nimport type { UseQueryOptions } from './useQuery'\nimport { cloneDeepUnref } from './utils'\n\n// Avoid TS depth-limit error in case of large array literal\ntype MAXIMUM_DEPTH = 20\n\ntype GetOptions<T> =\n  // Part 1: responsible for applying explicit type parameter to function arguments, if object { queryFnData: TQueryFnData, error: TError, data: TData }\n  T extends {\n    queryFnData: infer TQueryFnData\n    error?: infer TError\n    data: infer TData\n  }\n    ? UseQueryOptions<TQueryFnData, TError, TData>\n    : T extends { queryFnData: infer TQueryFnData; error?: infer TError }\n    ? UseQueryOptions<TQueryFnData, TError>\n    : T extends { data: infer TData; error?: infer TError }\n    ? UseQueryOptions<unknown, TError, TData>\n    : // Part 2: responsible for applying explicit type parameter to function arguments, if tuple [TQueryFnData, TError, TData]\n    T extends [infer TQueryFnData, infer TError, infer TData]\n    ? UseQueryOptions<TQueryFnData, TError, TData>\n    : T extends [infer TQueryFnData, infer TError]\n    ? UseQueryOptions<TQueryFnData, TError>\n    : T extends [infer TQueryFnData]\n    ? UseQueryOptions<TQueryFnData>\n    : // Part 3: responsible for inferring and enforcing type if no explicit parameter was provided\n    T extends {\n        queryFn?: QueryFunction<infer TQueryFnData, infer TQueryKey>\n        select: (data: any) => infer TData\n      }\n    ? UseQueryOptions<TQueryFnData, unknown, TData, TQueryKey>\n    : T extends { queryFn?: QueryFunction<infer TQueryFnData, infer TQueryKey> }\n    ? UseQueryOptions<TQueryFnData, unknown, TQueryFnData, TQueryKey>\n    : // Fallback\n      UseQueryOptions\n\ntype GetResults<T> =\n  // Part 1: responsible for mapping explicit type parameter to function result, if object\n  T extends { queryFnData: any; error?: infer TError; data: infer TData }\n    ? QueryObserverResult<TData, TError>\n    : T extends { queryFnData: infer TQueryFnData; error?: infer TError }\n    ? QueryObserverResult<TQueryFnData, TError>\n    : T extends { data: infer TData; error?: infer TError }\n    ? QueryObserverResult<TData, TError>\n    : // Part 2: responsible for mapping explicit type parameter to function result, if tuple\n    T extends [any, infer TError, infer TData]\n    ? QueryObserverResult<TData, TError>\n    : T extends [infer TQueryFnData, infer TError]\n    ? QueryObserverResult<TQueryFnData, TError>\n    : T extends [infer TQueryFnData]\n    ? QueryObserverResult<TQueryFnData>\n    : // Part 3: responsible for mapping inferred type to results, if no explicit parameter was provided\n    T extends {\n        queryFn?: QueryFunction<unknown, any>\n        select: (data: any) => infer TData\n      }\n    ? QueryObserverResult<TData>\n    : T extends { queryFn?: QueryFunction<infer TQueryFnData, any> }\n    ? QueryObserverResult<TQueryFnData>\n    : // Fallback\n      QueryObserverResult\n\n/**\n * UseQueriesOptions reducer recursively unwraps function arguments to infer/enforce type param\n */\nexport type UseQueriesOptions<\n  T extends any[],\n  Result extends any[] = [],\n  Depth extends ReadonlyArray<number> = [],\n> = Depth['length'] extends MAXIMUM_DEPTH\n  ? UseQueryOptions[]\n  : T extends []\n  ? []\n  : T extends [infer Head]\n  ? [...Result, GetOptions<Head>]\n  : T extends [infer Head, ...infer Tail]\n  ? UseQueriesOptions<[...Tail], [...Result, GetOptions<Head>], [...Depth, 1]>\n  : unknown[] extends T\n  ? T\n  : // If T is *some* array but we couldn't assign unknown[] to it, then it must hold some known/homogenous type!\n  // use this to infer the param types in the case of Array.map() argument\n  T extends UseQueryOptions<\n      infer TQueryFnData,\n      infer TError,\n      infer TData,\n      infer TQueryKey\n    >[]\n  ? UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>[]\n  : // Fallback\n    UseQueryOptions[]\n\n/**\n * UseQueriesResults reducer recursively maps type param to results\n */\nexport type UseQueriesResults<\n  T extends any[],\n  Result extends any[] = [],\n  Depth extends ReadonlyArray<number> = [],\n> = Depth['length'] extends MAXIMUM_DEPTH\n  ? QueryObserverResult[]\n  : T extends []\n  ? []\n  : T extends [infer Head]\n  ? [...Result, GetResults<Head>]\n  : T extends [infer Head, ...infer Tail]\n  ? UseQueriesResults<[...Tail], [...Result, GetResults<Head>], [...Depth, 1]>\n  : T extends UseQueryOptions<\n      infer TQueryFnData,\n      infer TError,\n      infer TData,\n      any\n    >[]\n  ? // Dynamic-size (homogenous) UseQueryOptions array: map directly to array of results\n    QueryObserverResult<unknown extends TData ? TQueryFnData : TData, TError>[]\n  : // Fallback\n    QueryObserverResult[]\n\ntype UseQueriesOptionsArg<T extends any[]> = readonly [...UseQueriesOptions<T>]\n\nexport function useQueries<T extends any[]>({\n  queries,\n}: {\n  queries: Ref<UseQueriesOptionsArg<T>> | UseQueriesOptionsArg<T>\n}): Readonly<UseQueriesResults<T>> {\n  const unreffedQueries = cloneDeepUnref(queries) as UseQueriesOptionsArg<T>\n\n  const queryClientKey = unreffedQueries[0].queryClientKey\n  const optionsQueryClient = unreffedQueries[0].queryClient\n  const queryClient = optionsQueryClient ?? useQueryClient(queryClientKey)\n  const defaultedQueries = unreffedQueries.map((options) => {\n    return queryClient.defaultQueryOptions(options)\n  })\n\n  const observer = new QueriesObserver(queryClient, defaultedQueries)\n  const state = reactive(observer.getCurrentResult())\n\n  const unsubscribe = observer.subscribe((result) => {\n    state.splice(0, state.length, ...result)\n  })\n\n  watch(\n    () => queries,\n    () => {\n      const defaulted = (\n        cloneDeepUnref(queries) as UseQueriesOptionsArg<T>\n      ).map((options) => {\n        return queryClient.defaultQueryOptions(options)\n      })\n      observer.setQueries(defaulted)\n    },\n    { deep: true },\n  )\n\n  onScopeDispose(() => {\n    unsubscribe()\n  })\n\n  return readonly(state) as UseQueriesResults<T>\n}\n"],"names":["useQueries","queries","unreffedQueries","cloneDeepUnref","queryClientKey","optionsQueryClient","queryClient","useQueryClient","defaultedQueries","map","options","defaultQueryOptions","observer","QueriesObserver","state","reactive","getCurrentResult","unsubscribe","subscribe","result","splice","length","watch","defaulted","setQueries","deep","onScopeDispose","readonly"],"mappings":";;;;;AAAA;;AA+HO,SAASA,UAAT,CAAqC;AAC1CC,EAAAA,OAAAA;AAD0C,CAArC,EAI4B;AACjC,EAAA,MAAMC,eAAe,GAAGC,cAAc,CAACF,OAAD,CAAtC,CAAA;AAEA,EAAA,MAAMG,cAAc,GAAGF,eAAe,CAAC,CAAD,CAAf,CAAmBE,cAA1C,CAAA;AACA,EAAA,MAAMC,kBAAkB,GAAGH,eAAe,CAAC,CAAD,CAAf,CAAmBI,WAA9C,CAAA;EACA,MAAMA,WAAW,GAAGD,kBAAH,IAAA,IAAA,GAAGA,kBAAH,GAAyBE,cAAc,CAACH,cAAD,CAAxD,CAAA;AACA,EAAA,MAAMI,gBAAgB,GAAGN,eAAe,CAACO,GAAhB,CAAqBC,OAAD,IAAa;AACxD,IAAA,OAAOJ,WAAW,CAACK,mBAAZ,CAAgCD,OAAhC,CAAP,CAAA;AACD,GAFwB,CAAzB,CAAA;EAIA,MAAME,QAAQ,GAAG,IAAIC,eAAJ,CAAoBP,WAApB,EAAiCE,gBAAjC,CAAjB,CAAA;EACA,MAAMM,KAAK,GAAGC,QAAQ,CAACH,QAAQ,CAACI,gBAAT,EAAD,CAAtB,CAAA;AAEA,EAAA,MAAMC,WAAW,GAAGL,QAAQ,CAACM,SAAT,CAAoBC,MAAD,IAAY;IACjDL,KAAK,CAACM,MAAN,CAAa,CAAb,EAAgBN,KAAK,CAACO,MAAtB,EAA8B,GAAGF,MAAjC,CAAA,CAAA;AACD,GAFmB,CAApB,CAAA;AAIAG,EAAAA,KAAK,CACH,MAAMrB,OADH,EAEH,MAAM;IACJ,MAAMsB,SAAS,GACbpB,cAAc,CAACF,OAAD,CADE,CAEhBQ,GAFgB,CAEXC,OAAD,IAAa;AACjB,MAAA,OAAOJ,WAAW,CAACK,mBAAZ,CAAgCD,OAAhC,CAAP,CAAA;AACD,KAJiB,CAAlB,CAAA;IAKAE,QAAQ,CAACY,UAAT,CAAoBD,SAApB,CAAA,CAAA;AACD,GATE,EAUH;AAAEE,IAAAA,IAAI,EAAE,IAAA;AAAR,GAVG,CAAL,CAAA;AAaAC,EAAAA,cAAc,CAAC,MAAM;IACnBT,WAAW,EAAA,CAAA;AACZ,GAFa,CAAd,CAAA;EAIA,OAAOU,QAAQ,CAACb,KAAD,CAAf,CAAA;AACD;;;;"}